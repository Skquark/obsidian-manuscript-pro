import { App, TFile, Notice } from 'obsidian';
import ManuscriptProPlugin from '../main';

/**
 * Comprehensive Report Options
 */
export interface ComprehensiveReportOptions {
	includeManuscriptInfo: boolean;
	includeTimeline: boolean;
	includeCharacters: boolean;
	includeResearch: boolean;
	includeStatistics: boolean;
	includeStyleCheck: boolean;
	format: 'markdown' | 'html';
}

/**
 * Comprehensive Project Report Generator
 * Creates a unified report combining all manuscript data
 */
export class ComprehensiveReportGenerator {
	private app: App;
	private plugin: ManuscriptProPlugin;

	constructor(app: App, plugin: ManuscriptProPlugin) {
		this.app = app;
		this.plugin = plugin;
	}

	/**
	 * Generate comprehensive project report
	 */
	async generateReport(options: ComprehensiveReportOptions): Promise<string> {
		let report = '';

		// Header
		report += '# Manuscript Project Report\n\n';
		report += `**Generated:** ${new Date().toLocaleString()}\n\n`;
		report += '---\n\n';

		// Table of Contents
		report += '## Table of Contents\n\n';
		if (options.includeManuscriptInfo) report += '1. [Manuscript Overview](#manuscript-overview)\n';
		if (options.includeStatistics) report += '2. [Writing Statistics](#writing-statistics)\n';
		if (options.includeTimeline) report += '3. [Timeline Summary](#timeline-summary)\n';
		if (options.includeCharacters) report += '4. [Character Database](#character-database)\n';
		if (options.includeResearch) report += '5. [Research Notes](#research-notes)\n';
		if (options.includeStyleCheck) report += '6. [Style Analysis](#style-analysis)\n';
		report += '\n---\n\n';

		// Manuscript Overview
		if (options.includeManuscriptInfo) {
			report += await this.generateManuscriptSection();
		}

		// Writing Statistics
		if (options.includeStatistics) {
			report += await this.generateStatisticsSection();
		}

		// Timeline Summary
		if (options.includeTimeline && this.plugin.timelineManager) {
			report += this.generateTimelineSection();
		}

		// Character Database
		if (options.includeCharacters && this.plugin.characterManager) {
			report += this.generateCharactersSection();
		}

		// Research Notes
		if (options.includeResearch && this.plugin.researchManager) {
			report += this.generateResearchSection();
		}

		// Style Analysis
		if (options.includeStyleCheck) {
			report += this.generateStyleSection();
		}

		// Footer
		report += '\n---\n\n';
		report += '*Report generated by Manuscript Pro*\n';

		return report;
	}

	/**
	 * Generate manuscript overview section
	 */
	private async generateManuscriptSection(): Promise<string> {
		let section = '## Manuscript Overview\n\n';

		// Get manuscript info from outliner if available
		if (this.plugin.outlinerManager) {
			const structures = this.plugin.outlinerManager.getAllManuscripts();

			if (structures.length > 0) {
				const manuscript = structures[0]; // Primary manuscript

				section += `**Title:** ${manuscript.title}\n\n`;
				section += `**Word Count:** ${manuscript.wordCount.toLocaleString()}\n\n`;

				// Structure overview
				section += '### Structure\n\n';

				if (manuscript.hasParts) {
					section += `- **Parts:** ${manuscript.parts.length}\n`;
					const totalChapters = manuscript.parts.reduce((sum: number, part: any) => sum + (part.chapters?.length || 0), 0);
					const totalScenes = manuscript.parts.reduce((sum: number, part: any) => {
						return sum + (part.chapters?.reduce((chSum: number, ch: any) => chSum + (ch.scenes?.length || 0), 0) || 0);
					}, 0);
					section += `- **Chapters:** ${totalChapters}\n`;
					section += `- **Scenes:** ${totalScenes}\n`;
				} else {
					section += `- **Chapters:** ${manuscript.chapters.length}\n`;
					const totalScenes = manuscript.chapters.reduce((sum: number, ch: any) => sum + (ch.scenes?.length || 0), 0);
					section += `- **Scenes:** ${totalScenes}\n`;
				}
				section += '\n';
			}
		}

		// Vault statistics
		const files = this.app.vault.getMarkdownFiles();
		section += '### Vault Overview\n\n';
		section += `- **Total Markdown Files:** ${files.length}\n`;
		section += `- **Vault Path:** ${this.app.vault.getName()}\n`;
		section += '\n';

		section += '---\n\n';
		return section;
	}

	/**
	 * Generate writing statistics section
	 */
	private async generateStatisticsSection(): Promise<string> {
		let section = '## Writing Statistics\n\n';

		// Get active file word count
		const activeFile = this.app.workspace.getActiveFile();
		if (activeFile) {
			const content = await this.app.vault.read(activeFile);
			const wordCount = this.countWords(content);

			section += `**Current File:** ${activeFile.basename}\n`;
			section += `**Word Count:** ${wordCount.toLocaleString()}\n\n`;
		}

		// Progress from settings if available
		if (this.plugin.settings.quality?.progress?.enabled) {
			section += '### Progress Tracking\n\n';
			// Would need to access progress manager data
			section += '*Progress tracking is enabled*\n\n';
		}

		// Session statistics from statsData
		if (this.plugin.statsData) {
			const sessionWords = this.plugin.statsData.sessionWordCount || 0;
			section += `**Session Words:** ${sessionWords.toLocaleString()}\n\n`;
		}

		section += '---\n\n';
		return section;
	}

	/**
	 * Generate timeline section
	 */
	private generateTimelineSection(): string {
		let section = '## Timeline Summary\n\n';

		const manager = this.plugin.timelineManager!;
		const stats = manager.getStatistics();

		section += `**Total Events:** ${stats.totalEvents}\n\n`;

		// Events by type
		section += '### Events by Type\n\n';
		for (const [type, count] of Object.entries(stats.eventsByType)) {
			if (count > 0) {
				section += `- **${type}:** ${count}\n`;
			}
		}
		section += '\n';

		// Events by importance
		section += '### Events by Importance\n\n';
		for (const [importance, count] of Object.entries(stats.eventsByImportance)) {
			if (count > 0) {
				section += `- **${importance}:** ${count}\n`;
			}
		}
		section += '\n';

		// Date range
		if (stats.earliestEvent && stats.latestEvent) {
			section += '### Timeline Span\n\n';
			section += `**From:** ${manager.formatDate(stats.earliestEvent.startDate)}\n`;
			section += `**To:** ${manager.formatDate(stats.latestEvent.startDate)}\n`;
			if (stats.totalSpanDays) {
				section += `**Duration:** ${stats.totalSpanDays} days\n`;
			}
			section += '\n';
		}

		// Conflicts
		if (stats.unresolvedConflicts > 0) {
			section += `### ⚠️ Timeline Conflicts\n\n`;
			section += `**Unresolved Conflicts:** ${stats.unresolvedConflicts}\n\n`;
			section += '*Review timeline for conflicts that need resolution*\n\n';
		}

		section += '---\n\n';
		return section;
	}

	/**
	 * Generate characters section
	 */
	private generateCharactersSection(): string {
		let section = '## Character Database\n\n';

		const manager = this.plugin.characterManager!;
		const stats = manager.getStatistics();

		section += `**Total Characters:** ${stats.totalCharacters}\n\n`;

		// Characters by role
		section += '### Characters by Role\n\n';
		section += `- **Protagonists:** ${stats.byRole.protagonist}\n`;
		section += `- **Antagonists:** ${stats.byRole.antagonist}\n`;
		section += `- **Supporting:** ${stats.byRole.supporting}\n`;
		section += `- **Minor:** ${stats.byRole.minor}\n`;
		section += `- **Other:** ${stats.byRole.other}\n`;
		section += '\n';

		// Characters by importance
		section += '### Characters by Importance\n\n';
		section += `- **Major:** ${stats.byImportance.major}\n`;
		section += `- **Moderate:** ${stats.byImportance.moderate}\n`;
		section += `- **Minor:** ${stats.byImportance.minor}\n`;
		section += '\n';

		// Top characters by appearances
		const topCharacters = manager.getAllCharacters()
			.filter(c => c.appearances && c.appearances.length > 0)
			.sort((a, b) => (b.appearances?.length || 0) - (a.appearances?.length || 0))
			.slice(0, 5);

		if (topCharacters.length > 0) {
			section += '### Top Characters by Appearances\n\n';
			topCharacters.forEach((char, index) => {
				section += `${index + 1}. **${char.name}** - ${char.appearances?.length || 0} appearances\n`;
			});
			section += '\n';
		}

		section += '---\n\n';
		return section;
	}

	/**
	 * Generate research section
	 */
	private generateResearchSection(): string {
		let section = '## Research Notes\n\n';

		const manager = this.plugin.researchManager!;
		const stats = manager.getStatistics();

		section += `**Total Notes:** ${stats.totalNotes}\n\n`;

		// Notes by category
		section += '### Notes by Category\n\n';
		for (const [category, count] of Object.entries(stats.byCategory)) {
			if (count > 0) {
				section += `- **${category}:** ${count}\n`;
			}
		}
		section += '\n';

		// Notes by priority
		section += '### Notes by Priority\n\n';
		for (const [priority, count] of Object.entries(stats.byPriority)) {
			if (count > 0) {
				section += `- **${priority}:** ${count}\n`;
			}
		}
		section += '\n';

		// Notes by status
		section += '### Notes by Status\n\n';
		for (const [status, count] of Object.entries(stats.byStatus)) {
			if (count > 0) {
				section += `- **${status}:** ${count}\n`;
			}
		}
		section += '\n';

		// Notes needing attention
		const needsVerification = manager.filterNotes({ status: 'to-verify' }).length;
		const needsCitation = manager.filterNotes({ status: 'needs-citation' }).length;

		if (needsVerification > 0 || needsCitation > 0) {
			section += '### Notes Requiring Attention\n\n';
			if (needsVerification > 0) {
				section += `- **To Verify:** ${needsVerification}\n`;
			}
			if (needsCitation > 0) {
				section += `- **Needs Citation:** ${needsCitation}\n`;
			}
			section += '\n';
		}

		// Top tags
		const topTags = stats.mostUsedTags.slice(0, 10);
		if (topTags.length > 0) {
			section += '### Most Common Tags\n\n';
			topTags.forEach((item: { tag: string; count: number }) => {
				section += `- #${item.tag} (${item.count})\n`;
			});
			section += '\n';
		}

		section += '---\n\n';
		return section;
	}

	/**
	 * Generate style analysis section
	 */
	private generateStyleSection(): string {
		let section = '## Style Analysis\n\n';

		// Check if style checker is enabled
		if (!this.plugin.settings.styleChecker?.enabled) {
			section += '*Style checker is not enabled*\n\n';
			section += '---\n\n';
			return section;
		}

		section += '### Style Checker Status\n\n';
		section += `**Enabled Rule Sets:** ${this.plugin.settings.styleChecker.enabledRuleSets.join(', ')}\n\n`;

		if (this.plugin.settings.styleChecker.customRules) {
			section += `**Custom Rules:** ${this.plugin.settings.styleChecker.customRules.length}\n\n`;
		}

		section += '*Run style checker on individual files for detailed analysis*\n\n';
		section += '---\n\n';

		return section;
	}

	/**
	 * Count words in text
	 */
	private countWords(text: string): number {
		// Remove frontmatter
		text = text.replace(/^---\n[\s\S]*?\n---\n/, '');

		// Remove code blocks
		text = text.replace(/```[\s\S]*?```/g, '');

		// Remove inline code
		text = text.replace(/`[^`]*`/g, '');

		// Count words
		const words = text.match(/\b\w+\b/g);
		return words ? words.length : 0;
	}

	/**
	 * Save report to file
	 */
	async saveReport(content: string, format: 'markdown' | 'html'): Promise<void> {
		try {
			const timestamp = new Date().toISOString().split('T')[0];
			const extension = format === 'html' ? 'html' : 'md';
			const filename = `manuscript_report_${timestamp}.${extension}`;

			// Get active file's directory or use root
			const activeFile = this.app.workspace.getActiveFile();
			const exportPath = activeFile?.parent?.path
				? `${activeFile.parent.path}/${filename}`
				: filename;

			// Check if file exists
			const existingFile = this.app.vault.getAbstractFileByPath(exportPath);
			if (existingFile instanceof TFile) {
				// Overwrite existing file
				await this.app.vault.modify(existingFile, content);
			} else {
				// Create new file
				await this.app.vault.create(exportPath, content);
			}

			new Notice(`Project report saved to ${filename}`);
		} catch (error) {
			console.error('Failed to save comprehensive report:', error);
			new Notice('Failed to save project report');
		}
	}
}
